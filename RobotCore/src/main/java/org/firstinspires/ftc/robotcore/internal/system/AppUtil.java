/*
Copyright (c) 2016 Robert Atkinson

All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted (subject to the limitations in the disclaimer below) provided that
the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list
of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

Neither the name of Robert Atkinson nor the names of his contributors may be used to
endorse or promote products derived from this software without specific prior
written permission.

NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESSFOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
package org.firstinspires.ftc.robotcore.internal.system;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.AlertDialog;
import android.app.Application;
import android.app.PendingIntent;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.support.annotation.ColorInt;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.InputType;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.qualcomm.robotcore.R;
import com.qualcomm.robotcore.robocol.Command;
import com.qualcomm.robotcore.util.RobotLog;

import org.firstinspires.ftc.robotcore.external.Consumer;
import org.firstinspires.ftc.robotcore.external.Predicate;
import org.firstinspires.ftc.robotcore.internal.collections.MutableReference;
import org.firstinspires.ftc.robotcore.internal.files.MediaTransferProtocolMonitor;
import org.firstinspires.ftc.robotcore.internal.network.NetworkConnectionHandler;
import org.firstinspires.ftc.robotcore.internal.network.RobotCoreCommandList;
import org.firstinspires.ftc.robotcore.internal.ui.ProgressParameters;
import org.firstinspires.ftc.robotcore.internal.ui.UILocation;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;

/**
 * {@link AppUtil} contains a few utilities related to application and activity management.
 */
@SuppressWarnings({"WeakerAccess", "JavaDoc"})
public class AppUtil
    {
    //----------------------------------------------------------------------------------------------
    // Directory management
    // See also OnBotJavaManager.
    //----------------------------------------------------------------------------------------------

    /** The root of all external storage that we use */
    public static final File ROOT_FOLDER = Environment.getExternalStorageDirectory();

    /** Where to place logs */
    public static final File LOG_FOLDER = ROOT_FOLDER;

    /** {@link #FIRST_FOLDER} is the root of the tree we use in non-volatile storage. Robot configurations
     * are stored in this folder. */
    public static final File FIRST_FOLDER = new File(ROOT_FOLDER + "/FIRST/");

    /** Dirctory in which .xml robot configurations should live */
    public static final File CONFIG_FILES_DIR = FIRST_FOLDER;

    /** Opmodes generated by the blocks programming tool are stored in {@link #BLOCK_OPMODES_DIR} */
    public static final File BLOCK_OPMODES_DIR = new File(FIRST_FOLDER, "/blocks/");
    public static final String BLOCKS_BLK_EXT = ".blk";
    public static final String BLOCKS_JS_EXT = ".js";

    /** {@link #ROBOT_SETTINGS} is a folder in which it's convenient to store team-generated settings
     * associated with their robot */
    public static final File ROBOT_SETTINGS = new File(FIRST_FOLDER, "/settings/");

    /** {@link #ROBOT_DATA_DIR} is a convenient place in which to put persistent data created by your opmode */
    public static final File ROBOT_DATA_DIR = new File(FIRST_FOLDER, "/data/");

    /** {@link #UPDATES_DIR} is a folder used to manage updates to firmware, installed APKs, and other components */
    public static final File UPDATES_DIR = new File(FIRST_FOLDER, "/updates/");
    public static final File RC_APP_UPDATE_DIR = new File(UPDATES_DIR, "/Robot Controller Application/");
    public static final File LYNX_FIRMWARE_UPDATE_DIR = new File(UPDATES_DIR, "/Expansion Hub Firmware/");

    //----------------------------------------------------------------------------------------------
    // Static State
    //----------------------------------------------------------------------------------------------

    public static final String TAG= "AppUtil";

    private static class InstanceHolder
        {
        public static AppUtil theInstance = new AppUtil();
        }

    public static AppUtil getInstance()
        {
        return InstanceHolder.theInstance;
        }

    public static Context getDefContext()
        {
        return getInstance().getApplication();
        }

    //----------------------------------------------------------------------------------------------
    // State
    //----------------------------------------------------------------------------------------------

    private @NonNull Application application;
    private LifeCycleMonitor    lifeCycleMonitor;
    private Activity            rootActivity;
    private Activity            currentActivity;
    private ProgressDialog      currentProgressDialog;

    //----------------------------------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------------------------------

    public static void onApplicationStart(@NonNull Application application)
        {
        getInstance().initialize(application);
        }

    protected AppUtil()
        {
        }

    protected void initialize(@NonNull Application application)
        {
        lifeCycleMonitor = new LifeCycleMonitor();
        rootActivity     = null;
        currentActivity  = null;
        currentProgressDialog = null;

        application.registerActivityLifecycleCallbacks(lifeCycleMonitor);

        // REVIEW: Why do this AFTER registering?
        this.application = application;
        
        RobotLog.vv(TAG, "initializing: getExternalStorageDirectory()=%s", Environment.getExternalStorageDirectory());
        }

    //----------------------------------------------------------------------------------------------
    // File and Directory Management
    //----------------------------------------------------------------------------------------------

    /**
     * Given a root File and a child underneath same returns the path from the former to the latter
     */
    public File getRelativePath(File root, File child)
        {
        File result = new File("");
        while (!root.equals(child))
            {
            File parent = child.getParentFile();
            result = new File(new File(child.getName()), result.getPath());
            if (parent == null) break;
            child = parent;
            }
        return result;
        }

    /**
     * Make sure all the components of the path exist, notifying MTP if necessary for any creations
     */
    public void ensureDirectoryExists(final File directory)
        {
        ensureDirectoryExists(directory, true);
        }
    public void ensureDirectoryExists(final File directory, boolean notify)
        {
        if (!directory.isDirectory())
            {
            directory.delete(); // might be a file; get rid of same

            File parent = directory.getParentFile();
            if (parent != null)
                {
                ensureDirectoryExists(parent, notify);
                }

            if (directory.mkdir())
                {
                // Successfully newly created the dir. Notify MTP. However, MTP doesn't like to be
                // notified of directories. So we make a temp file, notify on that, then delete same
                // once the scan has completed.
                if (notify) MediaTransferProtocolMonitor.makeIndicatorFile(directory);
                }
            else
                {
                // already existed, or error; latter ignored. Clean up any indicator files.
                if (notify)
                    {
                    MediaTransferProtocolMonitor.renoticeIndicatorFiles(directory);
                    }
                }
            }
        }

    public void deleteChildren(File file)
        {
        File[] children = file.listFiles();
        if (children != null)
            {
            for (File child : children)
                {
                delete(child);
                }
            }
        }

    /** Delete the indicated file or directory, clearing directories as needed */
    public void delete(File file)
        {
        deleteChildren(file);
        if (!file.delete())
            {
            RobotLog.ee(TAG, "failed to delete '%s'", file.getAbsolutePath());
            }
        }

    public List<File> filesUnder(File directory)
        {
        return filesUnder(directory, (Predicate<File>)null);
        }

    /** Return all the files (ie: not directories) under root for which predicate returns true */
    public List<File> filesUnder(File parent, @Nullable Predicate<File> predicate)
        {
        ArrayList<File> result = new ArrayList<>();
        if (parent.isDirectory())
            {
            for (File child : parent.listFiles())
                {
                result.addAll(filesUnder(child, predicate));
                }
            }
        else if (parent.exists())
            {
            if (predicate==null || predicate.test(parent))
                {
                result.add(parent.getAbsoluteFile());
                }
            }
        return result;
        }

    public List<File> filesUnder(File parent, @NonNull final String extension)
        {
        return filesUnder(parent, new Predicate<File>()
            {
            @Override public boolean test(File file)
                {
                return file.getName().endsWith(extension);
                }
            });
        }

    public List<File> filesIn(File directory)
        {
        return filesIn(directory, (Predicate<File>)null);
        }

    public List<File> filesIn(File directory, @Nullable Predicate<File> predicate)
        {
        ArrayList<File> result = new ArrayList<>();
        File[] children = directory.listFiles();
        if (children != null)
            {
            for (File child : children)
                {
                if (predicate==null || predicate.test(child))
                    {
                    result.add(child.getAbsoluteFile());
                    }
                }
            }
        return result;
        }

    public List<File> filesIn(File directory, @NonNull final String extension)
        {
        return filesIn(directory, new Predicate<File>()
            {
            @Override public boolean test(File file)
                {
                return file.getName().endsWith(extension);
                }
            });
        }

    public File getSettingsFile(String filename)
        {
        File file = new File(filename);
        if (!file.isAbsolute())
            {
            ensureDirectoryExists(ROBOT_SETTINGS);
            file = new File(ROBOT_SETTINGS, filename);
            }
        return file;
        }

    public void copyFile(File fromFile, File toFile) throws IOException
        {
        InputStream inputStream = new FileInputStream(fromFile);
        try {
            copyStream(inputStream, toFile);
            }
        finally
            {
            inputStream.close();
            }
        }

    public void copyStream(InputStream inputStream, File toFile) throws IOException
        {
        OutputStream outputStream = new FileOutputStream(toFile);
        try
            {
            copyStream(inputStream, outputStream);
            }
        finally
            {
            outputStream.close();
            }
        }

    public void copyStream(File inputFile, OutputStream outputStream) throws IOException
        {
        InputStream inputStream = new FileInputStream(inputFile);
        try {
            copyStream(inputStream, outputStream);
            }
        finally
            {
            inputStream.close();
            }
        }

    public void copyStream(InputStream inputStream, OutputStream outputStream) throws IOException
        {
        int cbBuffer = Math.min(4096, inputStream.available());
        byte[] buffer = new byte[cbBuffer];
        for (;;)
            {
            int cbRead = inputStream.read(buffer);
            if (cbRead <= 0) break;
            outputStream.write(buffer, 0, cbRead);
            }
        }

    //----------------------------------------------------------------------------------------------
    // Life Cycle
    //----------------------------------------------------------------------------------------------

    /**
     * Restarts the current application
     * @param exitCode the exit code to return from the current app run
     */
    public void restartApp(int exitCode)
        {
        // See http://stackoverflow.com/questions/2681499/android-how-to-auto-restart-application-after-its-been-force-closed
        RobotLog.vv(TAG, "restarting app");

        @SuppressWarnings("WrongConstant") PendingIntent pendingIntent = PendingIntent.getActivity(
                getApplication().getBaseContext(),
                0,
                new Intent(rootActivity.getIntent()),
                rootActivity.getIntent().getFlags());

        // Carry out the restart by having the AlarmManager (re)issue our intent after a delay
        // that's long enough for us to get out of the way in the first place.
        int msRestartDelay = 1500;
        AlarmManager alarmManager = (AlarmManager) rootActivity.getSystemService(Context.ALARM_SERVICE);
        alarmManager.set(AlarmManager.RTC, System.currentTimeMillis() + msRestartDelay, pendingIntent);
        System.exit(exitCode);
        }

    public void finishRootActivityAndExitApp()
        {
        synchronousRunOnUiThread(new Runnable()
            {
            @Override public void run()
                {
                RobotLog.vv(TAG, "finishRootActivityAndExitApp()");
                if (Build.VERSION.SDK_INT >= 21)
                    {
                    rootActivity.finishAndRemoveTask();
                    }
                else
                    {
                    rootActivity.finish();
                    }
                exitApplication();
                }
            });
        }

    public void exitApplication(int resultCode)
        {
        RobotLog.vv(TAG, "exitApplication(%d)", resultCode);
        System.exit(resultCode);
        }

    public void exitApplication()
        {
        exitApplication(0);
        }

    //----------------------------------------------------------------------------------------------
    // Application
    //----------------------------------------------------------------------------------------------

    /**
     * Returns the contextually running {@link Application}
     * @return the contextually running {@link Application}
     */
    public @NonNull Application getApplication()
        {
        return this.application;
        }

    /**
     * Returns the application id of this current application, the identifier
     * that distinguishes it from all other applications. This is the 'packageName' in
     * the ultimately-shipped manifest, but that differs from the 'packageName' attribute
     * in the source AndroidManifest.xml.
     *
     * @see <a href="https://developer.android.com/studio/build/application-id.html">Application Id</a>
     */
    public String getApplicationId()
        {
        return getApplication().getPackageName();
        }

    public boolean isRobotController()
        {
        return getApplicationId().equals(getDefContext().getString(R.string.packageNameRobotController));
        }

    public boolean isDriverStation()
        {
        return getApplicationId().equals(getDefContext().getString(R.string.packageNameDriverStation));
        }

    public String getAppName()
        {
        if (isRobotController())
            return getDefContext().getString(R.string.appNameRobotController);
        else if (isDriverStation())
            return getDefContext().getString(R.string.appNameDriverStation);
        else
            return getDefContext().getString(R.string.appNameUnknown);
        }

    public String getRemoteAppName()
        {
        if (isRobotController())
            return getDefContext().getString(R.string.appNameDriverStation);
        else if (isDriverStation())
            return getDefContext().getString(R.string.appNameRobotController);
        else
            return getDefContext().getString(R.string.appNameUnknown);
        }

    //----------------------------------------------------------------------------------------------
    // UI interaction
    //----------------------------------------------------------------------------------------------

    public @ColorInt int getColor(int id)
        {
        if (Build.VERSION.SDK_INT >= 23)
            {
            return getDefContext().getColor(id);
            }
        else
            {
            return getDefContext().getResources().getColor(id);
            }
        }

    /**
     * This works around a deliberate bug Google introduced to prevent options menus from working
     * on large screens. It is a hack, in the classic sense of the word. But it works. Onward...
     *
     * @param activity the guy whose options menu is to be opened
     * @see <a href="http://stackoverflow.com/questions/9996333/openoptionsmenu-function-not-working-in-ics/17903128#17903128">discussion</a>
     */
    public void openOptionsMenuFor(Activity activity)
        {
        Configuration config = activity.getResources().getConfiguration();
        if ((config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) > Configuration.SCREENLAYOUT_SIZE_LARGE)
            {
            int originalScreenLayout = config.screenLayout;
            config.screenLayout = Configuration.SCREENLAYOUT_SIZE_LARGE;
            try {
                activity.openOptionsMenu();
                }
            finally
                {
                config.screenLayout = originalScreenLayout;
                }
            }
        else
            {
            activity.openOptionsMenu();
            }
        }

    /**
     * A drop-in replacement for {@link Activity#runOnUiThread(Runnable) runonUiThread()} which doesn't
     * return until the UI action is complete.
     * @param action the action to perform on the UI thread
     */
    public void synchronousRunOnUiThread(final Runnable action)
        {
        synchronousRunOnUiThread(getActivity(), action);
        }

    public void synchronousRunOnUiThread(Activity activity, final Runnable action)
        {
        try {
            final CountDownLatch uiDone = new CountDownLatch(1);
            activity.runOnUiThread(new Runnable()
                {
                @Override public void run()
                    {
                    action.run();
                    uiDone.countDown();
                    }
                });
            uiDone.await();
            }
        catch (InterruptedException e)
            {
            Thread.currentThread().interrupt();
            }
        }

    /**
     * A simple helper so that callers have syntactically similar forms for both synchronous and non.
     */
    public void runOnUiThread(final Runnable action)
        {
        runOnUiThread(getActivity(), action);
        }

    public void runOnUiThread(Activity activity, final Runnable action)
        {
        activity.runOnUiThread(action);
        }

    public void showWaitCursor(@NonNull final String message, @NonNull final Runnable runnable)
        {
        showWaitCursor(message, runnable, null);
        }

    public void showWaitCursor(@NonNull final String message, @NonNull final Runnable backgroundWorker, @Nullable final Runnable runPostOnUIThread)
        {
        this.runOnUiThread(new Runnable()
            {
            @Override public void run()
                {
                new AsyncTask<Object,Void,Void>()
                    {
                    ProgressDialog dialog;

                    @Override protected void onPreExecute()
                        {
                        dialog = new ProgressDialog(getActivity());
                        dialog.setMessage(message);
                        dialog.setIndeterminate(true);
                        dialog.setCancelable(false);
                        dialog.show();
                        }

                    @Override protected Void doInBackground(Object... params)
                        {
                        backgroundWorker.run();
                        return null;
                        }

                    @Override protected void onPostExecute(Void aVoid)
                        {
                        dialog.dismiss();
                        if (runPostOnUIThread != null)
                            {
                            runPostOnUIThread.run();
                            }
                        }
                    }.execute();
                }
            });
        }

    //----------------------------------------------------------------------------------------------
    // Progress Dialog remoting
    //----------------------------------------------------------------------------------------------

    public void showProgress(UILocation uiLocation, final String message, final double fractionComplete)
        {
        showProgress(uiLocation, message, ProgressParameters.fromFraction(fractionComplete));
        }
    public void showProgress(UILocation uiLocation, final String message, final double fractionComplete, int max)
        {
        showProgress(uiLocation, message, ProgressParameters.fromFraction(fractionComplete, max));
        }
    public void showProgress(UILocation uiLocation, final String message, ProgressParameters progressParameters)
        {
        showProgress(uiLocation, this.getActivity(), message, progressParameters);
        }

    public void showProgress(UILocation uiLocation, final Activity activity, final String message, final ProgressParameters progressParameters)
        {
        final int maxMax = 10000;   // per ProgressBar.MAX_LEVEL
        final int cappedMax = Math.min(progressParameters.max, maxMax);

        this.runOnUiThread(new Runnable()
            {
            @Override public void run()
                {
                if (currentProgressDialog == null)
                    {
                    currentProgressDialog = new ProgressDialog(activity);
                    currentProgressDialog.setMessage(message);
                    currentProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
                    currentProgressDialog.setMax(cappedMax);
                    currentProgressDialog.setProgress(0);
                    currentProgressDialog.setCanceledOnTouchOutside(false);
                    currentProgressDialog.show();
                    }
                currentProgressDialog.setProgress(progressParameters.cur);
                }
            });

        if (uiLocation == UILocation.BOTH)
            {
            RobotCoreCommandList.ShowProgress showProgress = new RobotCoreCommandList.ShowProgress();
            showProgress.message = message;
            showProgress.cur = progressParameters.cur;
            showProgress.max = progressParameters.max;
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_SHOW_PROGRESS, showProgress.serialize()));
            }
        }

    public void dismissProgress(UILocation uiLocation)
        {
        this.runOnUiThread(new Runnable()
            {
            @Override public void run()
                {
                if (currentProgressDialog != null)
                    {
                    currentProgressDialog.dismiss();
                    currentProgressDialog = null;
                    }
                }
            });

        if (uiLocation == UILocation.BOTH)
            {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_DISMISS_PROGRESS));
            }
        }

    //----------------------------------------------------------------------------------------------
    // Alert / Confirm / Prompt Dialog
    // https://developer.android.com/guide/topics/ui/dialogs.html
    //----------------------------------------------------------------------------------------------

    public enum DialogFlavor { ALERT, CONFIRM, PROMPT }

    private Map<String, DialogContext> dialogContextMap = new ConcurrentHashMap<>();

    public static class DialogContext
        {
        public enum Outcome { UNKNOWN, CANCELLED, CONFIRMED }

        public final CountDownLatch dismissed = new CountDownLatch(1);

        protected final String         uuidString;
        protected AlertDialog          dialog;
        protected boolean              isArmed = true;
        protected Outcome              outcome = Outcome.UNKNOWN;
        protected CharSequence         textResult = null;
        protected EditText             input = null;

        public DialogContext(String uuidString)
            {
            this.uuidString = uuidString;
            }

        public Outcome getOutcome()
            {
            return outcome;
            }

        public CharSequence getText()
            {
            return textResult;
            }
        }

    public DialogContext showAlertDialog(UILocation uiLocation, String title, String message)
        {
        return showAlertDialog(uiLocation, getActivity(), title, message);
        }
    public DialogContext showAlertDialog(String uuidString, UILocation uiLocation, String title, String message) // for remoting
        {
        return showDialog(uuidString, uiLocation, DialogFlavor.ALERT, getActivity(), title, message, null, null);
        }
    public synchronized DialogContext showAlertDialog(final UILocation uiLocation, final Activity activity, final String title, final String message)
        {
        return showDialog(uiLocation, DialogFlavor.ALERT, activity, title, message, null, null);
        }

    public synchronized DialogContext showDialog(
                 final UILocation uiLocation, final DialogFlavor flavor, final Activity activity,
                 final String title, final String message, @Nullable final String defaultValue,
                 @Nullable final Consumer<DialogContext> runOnDismiss)
        {
        return showDialog(null, uiLocation, flavor, activity, title, message, defaultValue, runOnDismiss);
        }

    private synchronized DialogContext showDialog(@Nullable String uuidString,
                 final UILocation uiLocation, final DialogFlavor flavor, final Activity activity,
                 final String title, final String message, @Nullable final String defaultValue,
                 @Nullable final Consumer<DialogContext> runOnDismiss)
        {
        final RobotCoreCommandList.ShowDialog showDialog = new RobotCoreCommandList.ShowDialog();
        showDialog.title = title;
        showDialog.message = message;
        showDialog.uuidString = uuidString != null ? uuidString : UUID.randomUUID().toString();

        final MutableReference<DialogContext> result = new MutableReference<>();
        this.synchronousRunOnUiThread(new Runnable() // note the synchronicity
            {
            @Override public void run()
                {
                // Whenever the dialog goes away, for whatever reason, we need to (a) fire the
                // CountDownLatch to unstick whomever might be awaiting, and (b) make sure to dismiss
                // from the other side, too, if appropriate.
                final DialogContext dialogContext = new DialogContext(showDialog.uuidString);

                AlertDialog.Builder builder = new AlertDialog.Builder(activity);
                builder.setTitle(title);
                builder.setMessage(message);
                switch (flavor)
                    {
                    case ALERT:
                        builder.setNeutralButton(R.string.buttonNameOK, new DialogInterface.OnClickListener()
                            {
                            @Override public void onClick(DialogInterface dialog, int which)
                                {
                                dialogContext.outcome = DialogContext.Outcome.CONFIRMED;
                                }
                            });
                        break;
                    case PROMPT:
                        // https://stackoverflow.com/questions/10903754/input-text-dialog-android
                        dialogContext.input = new EditText(activity);
                        dialogContext.input.setInputType(InputType.TYPE_CLASS_TEXT);
                        if (defaultValue != null) dialogContext.input.setText(defaultValue);
                        builder.setView(dialogContext.input);
                        // fall through
                    case CONFIRM:
                        if (uiLocation != UILocation.ONLY_LOCAL) throw new IllegalArgumentException("remote confirmation dialogs not yet supported");
                        builder.setPositiveButton(R.string.buttonNameOK, new DialogInterface.OnClickListener()
                            {
                            @Override public void onClick(DialogInterface dialog, int which)
                                {
                                RobotLog.vv(TAG, "dialog OK clicked: uuid=%s", dialogContext.uuidString);
                                dialogContext.outcome = DialogContext.Outcome.CONFIRMED;
                                // Capture the text while we know we're on a good thread
                                if (dialogContext.input != null)
                                    {
                                    dialogContext.textResult = dialogContext.input.getText();
                                    }
                                dialog.dismiss();
                                }
                            });
                        builder.setNegativeButton(R.string.buttonNameCancel, new DialogInterface.OnClickListener()
                            {
                            @Override public void onClick(DialogInterface dialog, int which)
                                {
                                RobotLog.vv(TAG, "dialog cancel clicked: uuid=%s", dialogContext.uuidString);
                                dialog.cancel();
                                }
                            });
                        break;
                    }

                dialogContext.dialog = builder.create();
                dialogContext.dialog.setOnShowListener(new DialogInterface.OnShowListener()
                    {
                    @Override public void onShow(DialogInterface dialog)
                        {
                        RobotLog.vv(TAG, "dialog shown: uuid=%s", dialogContext.uuidString);
                        }
                    });
                dialogContext.dialog.setOnCancelListener(new DialogInterface.OnCancelListener()
                    {
                    @Override public void onCancel(DialogInterface dialog)
                        {
                        RobotLog.vv(TAG, "dialog cancelled: uuid=%s", dialogContext.uuidString);
                        dialogContext.outcome = DialogContext.Outcome.CANCELLED;
                        }
                    });
                dialogContext.dialog.setOnDismissListener(new DialogInterface.OnDismissListener()
                    {
                    @Override public void onDismiss(DialogInterface dialog)
                        {
                        RobotLog.vv(TAG, "dialog dismissed: uuid=%s", dialogContext.uuidString);
                        dialogContext.dismissed.countDown();
                        if (runOnDismiss != null)
                            {
                            runOnUiThread(activity, new Runnable()
                                {
                                @Override public void run()
                                    {
                                    runOnDismiss.accept(dialogContext);
                                    }
                                });
                            }
                        if (dialogContext.isArmed)
                            {
                            // Actively dismissing on the DS should also dismiss on the RC, and visa versa
                            RobotCoreCommandList.DismissDialog dismissDialog = new RobotCoreCommandList.DismissDialog(showDialog.uuidString);
                            dismissDialog(UILocation.BOTH, dismissDialog);
                            }
                        }
                    });

                dialogContextMap.put(dialogContext.uuidString, dialogContext);
                result.value = dialogContext;
                dialogContext.dialog.show();
				}
            });

        Assert.assertNotNull(result.value);

        if (uiLocation==UILocation.BOTH)
            {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_SHOW_DIALOG, showDialog.serialize()));
            }

        return result.value;
        }

    public void dismissDialog(UILocation uiLocation, RobotCoreCommandList.DismissDialog dismissDialog)
        {
        dismissDialog(dismissDialog.uuidString);
        if (uiLocation==UILocation.BOTH)
            {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_DISMISS_DIALOG, dismissDialog.serialize()));
            }
        }

    protected void dismissDialog(final String uuidString)
        {
        this.runOnUiThread(new Runnable()
            {
            @Override public void run()
                {
                DialogContext dialogContext = dialogContextMap.remove(uuidString);
                if (dialogContext != null)
                    {
                    dialogContext.isArmed = false;
                    dialogContext.dialog.dismiss();
                    }
                }
            });
        }

    public void dismissAllDialogs(UILocation uiLocation)
        {
        List<String> uuidStrings = new ArrayList<>(dialogContextMap.keySet());
        for (String uuidString : uuidStrings)
            {
            dismissDialog(uuidString);
            }
        if (uiLocation == UILocation.BOTH)
            {
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_DISMISS_ALL_DIALOGS));
            }
        }

    //----------------------------------------------------------------------------------------------
    // Toast
    //----------------------------------------------------------------------------------------------

    /**
     * Displays a toast message to the user. May be called from any thread.
     */
    public void showToast(UILocation uiLocation, String msg)
        {
        showToast(uiLocation, getActivity(), getApplication(), msg);
        }
    public void showToast(UILocation uiLocation, String msg, int duration)
        {
        showToast(uiLocation, getActivity(), getApplication(), msg, duration);
        }
    public void showToast(UILocation uiLocation, Context context, String msg )
        {
        showToast(uiLocation, getActivity(), context, msg);
        }
    public void showToast(UILocation uiLocation, final Activity activity, Context context, String msg)
        {
        showToast(uiLocation, activity, context, msg, Toast.LENGTH_SHORT);
        }

    public void showToast(UILocation uiLocation, final Activity activity, final Context context, final String msg, final int duration)
        {
        activity.runOnUiThread(new Runnable()
            {
            @Override public void run()
                {
                Toast toast = Toast.makeText(context, msg, duration);
                TextView message = (TextView) toast.getView().findViewById(android.R.id.message);
                message.setTextColor(getColor(R.color.text_toast));
                message.setTextSize(18);
                toast.show();
                }
            });

        if (uiLocation==UILocation.BOTH)
            {
            RobotCoreCommandList.ShowToast showToast = new RobotCoreCommandList.ShowToast();
            showToast.message = msg;
            showToast.duration = duration;
            NetworkConnectionHandler.getInstance().sendCommand(new Command(RobotCoreCommandList.CMD_SHOW_TOAST, showToast.serialize()));
            }
        }

    //----------------------------------------------------------------------------------------------
    // Activities
    //----------------------------------------------------------------------------------------------

    /**
     * Returns the contextually running {@link Activity}
     * @return the contextually running {@link Activity}
     */
    public Activity getActivity()
        {
        return currentActivity;
        }

    /**
     * Returns the root activity of the current application
     * @return the root activity of the current application
     */
    public Activity getRootActivity()
        {
        return rootActivity;
        }

    private void initializeRootActivityIfNecessary()
        {
        if (rootActivity == null)
            {
            rootActivity = currentActivity;
            RobotLog.vv(TAG, "rootActivity=%s", rootActivity.getClass().getSimpleName());
            }
        }

    /**
     * {@link LifeCycleMonitor} is a class that allows us to keep track of the currently active Activity.
     */
    private class LifeCycleMonitor implements Application.ActivityLifecycleCallbacks
        {
        @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState)
            {
            currentActivity = activity;
            initializeRootActivityIfNecessary();
            }

        @Override public void onActivityStarted(Activity activity)
            {
            currentActivity = activity;
            initializeRootActivityIfNecessary();
            }

        @Override public void onActivityResumed(Activity activity)
            {
            currentActivity = activity;
            initializeRootActivityIfNecessary();
            }

        @Override public void onActivityPaused(Activity activity)
            {
            }

        @Override public void onActivityStopped(Activity activity)
            {
            }

        @Override public void onActivitySaveInstanceState(Activity activity, Bundle outState)
            {
            }

        @Override public void onActivityDestroyed(Activity activity)
            {
            if (activity == rootActivity && rootActivity != null)
                {
                RobotLog.vv(TAG, "rootActivity=%s destroyed", rootActivity.getClass().getSimpleName());
                rootActivity = null;
                }
            }
        }

    //----------------------------------------------------------------------------------------------
    // Date and time
    //----------------------------------------------------------------------------------------------

    public SimpleDateFormat getIso8601DateFormat()
        {
        // From https://en.wikipedia.org/wiki/ISO_8601
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US);
        formatter.setTimeZone(TimeZone.getTimeZone("UTC"));
        return formatter;
        }

    //----------------------------------------------------------------------------------------------
    // System
    //----------------------------------------------------------------------------------------------

    public RuntimeException unreachable()
        {
        return unreachable(TAG);
        }

    public RuntimeException unreachable(Throwable throwable)
        {
        return unreachable(TAG, throwable);
        }

    public RuntimeException unreachable(String tag)
        {
        return failFast(tag, "internal error: this code is unreachable");
        }

    public RuntimeException unreachable(String tag, Throwable throwable)
        {
        return failFast(tag, throwable, "internal error: this code is unreachable");
        }

    public RuntimeException failFast(String tag, String format, Object... args)
        {
        String message = String.format(format, args);
        return failFast(tag, message);
        }

    public RuntimeException failFast(String tag, String message)
        {
        RobotLog.ee(tag, message);
        exitApplication(-1);
        return new RuntimeException("keep compiler happy");
        }

    public RuntimeException failFast(String tag, Throwable throwable, String format, Object... args)
        {
        String message = String.format(format, args);
        return failFast(tag, throwable, message);
        }

    public RuntimeException failFast(String tag, Throwable throwable, String message)
        {
        RobotLog.ee(tag, throwable, message);
        exitApplication(-1);
        return new RuntimeException("keep compiler happy", throwable);
        }

    }
